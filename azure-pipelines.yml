trigger:
  branches:
    include:
      - main
  paths:
    exclude:
      - README.md
      - .gitignore
      - docs/**
      - "*.md"

variables:
  acrName: devopsecomacr1234.azurecr.io
  kubernetesNamespace: default
  imageTag: $(Build.BuildId)

parameters:
  - name: services
    type: object
    default:
      - name: frontend
        safeName: frontend
        path: app/frontend
        deployment: frontend
      - name: users-service
        safeName: users_service
        path: app/users-service
        deployment: users
      - name: products-service
        safeName: products_service
        path: app/products-service
        deployment: products
      - name: cart-service
        safeName: cart_service
        path: app/cart-service
        deployment: cart

stages:
- stage: Build
  displayName: "Build and Push Docker Images"
  jobs:
  - ${{ each service in parameters.services }}:
    - job: Build_${{ service.safeName }}
      displayName: "Build & Push ${{ service.name }}"
      pool:
        vmImage: "ubuntu-latest"
      steps:
        - checkout: self
        
        - task: Docker@2
          displayName: "Build ${{ service.name }}"
          inputs:
            containerRegistry: "acr-connection"
            repository: "${{ service.name }}"
            command: "build"
            Dockerfile: "${{ service.path }}/Dockerfile"
            tags: |
              $(imageTag)
              latest
        
        # Optional: Security scanning (can be disabled if not needed)
        - task: AzureContainerSecurityScan@0
          displayName: "Security Scan ${{ service.name }}"
          inputs:
            image: "$(acrName)/${{ service.name }}:$(imageTag)"
          continueOnError: true
        
        - task: Docker@2
          displayName: "Push ${{ service.name }}"
          inputs:
            containerRegistry: "acr-connection"
            repository: "${{ service.name }}"
            command: "push"
            tags: |
              $(imageTag)
              latest

- stage: Deploy
  displayName: "Deploy to Production"
  dependsOn: Build
  jobs:
  - deployment: Deploy_All_Services
    displayName: "Deploy All Services"
    pool:
      vmImage: "ubuntu-latest"
    environment: 'production'
    strategy:
      runOnce:
        deploy:
          steps:
          - checkout: self
          
          # Deploy all services
          - ${{ each service in parameters.services }}:
            - task: Kubernetes@1
              displayName: "Deploy ${{ service.name }}"
              inputs:
                connectionType: "Kubernetes Service Connection"
                kubernetesServiceEndpoint: "aks-connection"
                namespace: "$(kubernetesNamespace)"
                command: "set"
                arguments: >
                  image deployment/${{ service.deployment }}
                  ${{ service.deployment }}=$(acrName)/${{ service.name }}:$(imageTag)
            
            - task: Kubernetes@1
              displayName: "Rollout restart ${{ service.name }}"
              inputs:
                connectionType: "Kubernetes Service Connection"
                kubernetesServiceEndpoint: "aks-connection"
                namespace: "$(kubernetesNamespace)"
                command: "rollout"
                arguments: "restart deployment/${{ service.deployment }}"
            
            - task: Kubernetes@1
              displayName: "Wait for ${{ service.name }} rollout"
              inputs:
                connectionType: "Kubernetes Service Connection"
                kubernetesServiceEndpoint: "aks-connection"
                namespace: "$(kubernetesNamespace)"
                command: "rollout"
                arguments: "status deployment/${{ service.deployment }} --timeout=300s"
          
          # Final health check
          - task: Bash@3
            displayName: "Post-Deployment Health Check"
            inputs:
              targetType: 'inline'
              script: |
                echo "Running post-deployment health checks..."
                echo "All services deployed successfully!"
                kubectl get pods -n $(kubernetesNamespace)
                