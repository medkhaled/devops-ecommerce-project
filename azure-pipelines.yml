trigger:
  branches:
    include:
      - main
  paths:
    exclude:
      - README.md
      - .gitignore
      - docs/**
      - "*.md"

variables:
  acrName: devopsecomacr1234.azurecr.io
  kubernetesNamespace: default
  imageTag: $(Build.BuildId)

parameters:
  - name: services
    type: object
    default:
      - name: frontend
        safeName: frontend
        path: app/frontend
        deployment: frontend
      - name: users-service
        safeName: users_service
        path: app/users-service
        deployment: users
      - name: products-service
        safeName: products_service
        path: app/products-service
        deployment: products
      - name: cart-service
        safeName: cart_service
        path: app/cart-service
        deployment: cart

stages:
- stage: Build
  displayName: "Build and Push Docker Images"
  jobs:
  - ${{ each service in parameters.services }}:
    - job: Build_${{ service.safeName }}
      displayName: "Build & Push ${{ service.name }}"
      pool:
        vmImage: "ubuntu-latest"
      steps:
        - checkout: self
        
        - task: Docker@2
          displayName: "Build ${{ service.name }}"
          inputs:
            containerRegistry: "acr-connection"
            repository: "${{ service.name }}"
            command: "build"
            Dockerfile: "${{ service.path }}/Dockerfile"
            buildContext: "${{ service.path }}"
            tags: |
              $(imageTag)
              latest
              
        - task: Docker@2
          displayName: "Push ${{ service.name }}"
          inputs:
            containerRegistry: "acr-connection"
            repository: "${{ service.name }}"
            command: "push"
            tags: |
              $(imageTag)
              latest

- stage: Deploy
  displayName: "Deploy to Production"
  dependsOn: Build
  condition: succeeded()
  jobs:
  - job: Deploy_All_Services
    displayName: "Deploy All Services"
    pool:
      vmImage: "ubuntu-latest"
    steps:
      - checkout: self

      # Install kubectl if not available
      - task: KubectlInstaller@0
        displayName: 'Install kubectl'
        inputs:
          kubectlVersion: 'latest'

      # Deploy all services
      - ${{ each service in parameters.services }}:
        # Apply Kubernetes manifests
        - task: Kubectl@1
          displayName: "Apply manifests for ${{ service.name }}"
          inputs:
            connectionType: 'Kubernetes Service Connection'
            kubernetesServiceEndpoint: 'aks-connection'
            namespace: '$(kubernetesNamespace)'
            command: apply
            useConfigurationFile: true
            configuration: |
              k8s/${{ service.deployment }}-deployment.yaml
              k8s/${{ service.deployment }}-service.yaml

        # Update container image
        - task: Kubectl@1
          displayName: "Update image for ${{ service.name }}"
          inputs:
            connectionType: 'Kubernetes Service Connection'
            kubernetesServiceEndpoint: 'aks-connection'
            namespace: '$(kubernetesNamespace)'
            command: set
            arguments: >
              image deployment/${{ service.deployment }}
              ${{ service.name }}=$(acrName)/${{ service.name }}:$(imageTag)

        # Verify rollout
        - task: Kubectl@1
          displayName: "Verify ${{ service.name }} rollout"
          inputs:
            connectionType: "Kubernetes Service Connection"
            kubernetesServiceEndpoint: "aks-connection"
            namespace: "$(kubernetesNamespace)"
            command: "rollout"
            arguments: "status deployment/${{ service.deployment }} --timeout=300s"
      
      # Final health check
      - task: Kubectl@1
        displayName: "Get Pod Status"
        inputs:
          connectionType: "Kubernetes Service Connection"
          kubernetesServiceEndpoint: "aks-connection"
          namespace: "$(kubernetesNamespace)"
          command: "get"
          arguments: "pods -o wide"
      
      - task: Bash@3
        displayName: "Post-Deployment Health Check"
        inputs:
          targetType: 'inline'
          script: |
            echo "Running post-deployment health checks..."
            
            for deployment in frontend users products cart; do
              echo "Checking deployment: $deployment"
              kubectl get deployment/$deployment -n $(kubernetesNamespace) -o jsonpath='{.status.conditions[?(@.type=="Available")].status}'
              echo ""
            done
            
            echo "All services deployment status checked!"
            kubectl get all -n $(kubernetesNamespace)
