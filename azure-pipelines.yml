trigger:
  branches:
    include:
      - main
  paths:
    exclude:
      - README.md
      - .gitignore
      - docs/**
      - "*.md"

variables:
  acrName: devopsecomacr1234.azurecr.io
  kubernetesNamespace: default
  imageTag: $(Build.BuildId)

parameters:
  - name: services
    type: object
    default:
      - name: frontend
        safeName: frontend
        path: app/frontend
        deployment: frontend
      - name: users-service
        safeName: users_service
        path: app/users-service
        deployment: users
      - name: products-service
        safeName: products_service
        path: app/products-service
        deployment: products
      - name: cart-service
        safeName: cart_service
        path: app/cart-service
        deployment: cart

stages:
- stage: Build
  displayName: "Build and Push Docker Images"
  jobs:
  - ${{ each service in parameters.services }}:
    - job: Build_${{ service.safeName }}
      displayName: "Build & Push ${{ service.name }}"
      pool:
        vmImage: "ubuntu-latest"
      steps:
        - checkout: self
        
        - task: Docker@2
          displayName: "Build ${{ service.name }}"
          inputs:
            containerRegistry: "acr-connection"
            repository: "${{ service.name }}"
            command: "build"
            Dockerfile: "${{ service.path }}/Dockerfile"
            buildContext: "${{ service.path }}"
            tags: |
              $(imageTag)
              latest
              
        - task: Docker@2
          displayName: "Push ${{ service.name }}"
          inputs:
            containerRegistry: "acr-connection"
            repository: "${{ service.name }}"
            command: "push"
            tags: |
              $(imageTag)
              latest

- stage: Deploy
  displayName: "Deploy to Production"
  dependsOn: Build
  condition: succeeded()
  jobs:
  - job: Deploy_All_Services
    displayName: "Deploy All Services"
    pool:
      vmImage: "ubuntu-latest"
    steps:
      - checkout: self

      # Install kubectl
      - task: KubectlInstaller@0
        displayName: 'Install kubectl'
        inputs:
          kubectlVersion: 'latest'

      # Authenticate with AKS using Azure CLI
      - task: AzureCLI@2
        displayName: "AKS Login"
        inputs:
          azureSubscription: "aks-connection"
          scriptType: bash
          scriptLocation: inlineScript
          inlineScript: |
            echo "Getting AKS credentials..."
            az aks get-credentials --resource-group YOUR_RG --name YOUR_AKS_NAME --overwrite-existing

      # Deploy each service
      - ${{ each service in parameters.services }}:
        - task: Bash@3
          displayName: "Deploy ${{ service.name }}"
          inputs:
            targetType: inline
            script: |
              echo "Applying manifests for ${{ service.name }}..."
              kubectl apply -n $(kubernetesNamespace) -f k8s/${{ service.deployment }}-deployment.yaml
              kubectl apply -n $(kubernetesNamespace) -f k8s/${{ service.deployment }}-service.yaml
              
              echo "Updating image for ${{ service.name }}..."
              kubectl set image deployment/${{ service.deployment }} \
                ${{ service.name }}=$(acrName)/${{ service.name }}:$(imageTag) \
                -n $(kubernetesNamespace)

              echo "Waiting for rollout of ${{ service.name }}..."
              kubectl rollout status deployment/${{ service.deployment }} \
                -n $(kubernetesNamespace) --timeout=300s

      # Final health check
      - task: Bash@3
        displayName: "Post-Deployment Health Check"
        inputs:
          targetType: 'inline'
          script: |
            echo "Checking all pods in namespace $(kubernetesNamespace)..."
            kubectl get pods -o wide -n $(kubernetesNamespace)
            
            echo "Checking deployments availability..."
            for deployment in frontend users products cart; do
              echo "Deployment: $deployment"
              kubectl get deployment/$deployment -n $(kubernetesNamespace) -o jsonpath='{.status.conditions[?(@.type=="Available")].status}'
              echo ""
            done
            
            echo "Full cluster state:"
            kubectl get all -n $(kubernetesNamespace)
